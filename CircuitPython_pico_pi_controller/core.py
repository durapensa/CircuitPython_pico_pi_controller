# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['IDENTITY', 'IDF', 'HOS', 'LOD', 'TIM', 'PEN', 'PPDevice', 'PPController']

# Cell
from sys import byteorder, modules
from time import sleep, struct_time
import board
#import busio
from adafruit_bus_device import i2c_device
try:
    from rtc import RTC
except:
    pass
try:
    from adafruit_datetime import datetime
except:
    from datetime import datetime
try:
    from adafruit_itertools.adafruit_itertools import chain
except:
    from itertools import chain
try:
    import adafruit_logging as logging
except:
    import logging


try:
    logger = logging.getLogger('PPC')
except:
    logger = logging.getLogger()
logger.setLevel(logging.DEBUG)

try:
    logging.basicConfig(level = logging.DEBUG)
except:
    pass

IDENTITY = bytearray(([ord(c) for c in list('ppc-daemon')]))
"""identifier string used by RPi devices"""

IDF = bytearray(); IDF.append(ord('I')) # request to send identification
HOS = bytearray(); HOS.append(ord('H')) # request to send hostname
LOD = bytearray(); LOD.append(ord('L')) # request to send load
TIM = bytearray(); TIM.append(ord('T')) # request to send datetime
PEN = bytearray(); PEN.append(ord('P')) # request to send MCU pin connected to RPi PEN

# Cell
class PPDevice():
    """Represents an I2C peripheral device known to a `PPController`
    and stores data from those peripherals identified as PPC devices."""
    def __init__(self, controller=None, device_address=None, *argv, **kwargs):
        self.controller = controller
        self.device_address = device_address
        self.device=None

        self.retries = 0
        self.retries_max = 10
        """retry count before I2CDevice is considered 'other', i.e. not a PPC device."""

        """All data below are received *from* the PPC device:"""

        self.bosmang = None
        self.UART_RX = None
        """MCU GPIO RX for passthru from bosmang console TX"""
        self.UART_TX = None
        """MCU GPIO TX for passthru from bosmang console RX"""
        self.pen = None
        """MCU GPIO connected to RPi PEN pin"""


        self.hostname = None
        self.load = ""
        self.datetime = None
        """to send datetime as bosmang, and used to check for datetime skew
           on other devices."""

    def getHostname(self):
        return self.hostname

# Cell
class PPController():
    """Represents one of the system's I2C busses and tracks which I2C
    peripherals are `PPDevice`s."""
    def __init__(self, scl=board.SCL, sda=board.SDA, frequency=4800, timeout=10000):
        self.i2c = None
        self.scl = scl
        self.sda = sda
        self.frequency=frequency
        self.timeout=timeout

        self.bosmang = None
        """PPDevice hostname selected to recieve datetime & control instructions from,
           have UART connected for passthru, etc. Default is `None`."""

        self.devices = []
        self.noident = []
        self.othrdev = []

        self.datetime = None
        """future use for receiving datetime from bosmang"""

    def scanForNew(self):
        while not self.i2c.try_lock():
            pass
        logger.info("PPC: scanForNew: scanning I2C bus for PPController at SCL/SDA "
                    +str(self.scl)+"/"+str(self.sda))
        for addr in  self.i2c.scan():
            if not any(d.device_address == addr for d in chain(self.devices,self.noident,self.othrdev)):
                logger.info("PPC: scanForNew: found I2C peripheral "+str(hex(addr))+" on I2C bus for PPController at SCL/SDA "
                            +str(self.scl)+"/"+str(self.sda))
                self.noident.append(PPDevice(i2c=self.i2c,device_address=addr))
                self.noident[-1].device=i2c_device.I2CDevice(self.i2c,device_address=addr,probe=False)
                logger.info("PPC: scanForNew: added I2C peripheral "+str(hex(addr))+" object to PPController at SCL/SDA "
                            +str(self.scl)+"/"+str(self.sda))
        self.i2c.unlock()
        return True

    def identifyNew(self):
        for peripheral in self.noident:
            logger.info("PPC: identifyNew: querying I2C peripheral "+str(hex(peripheral.device_address))
                        +" at PPController at SCL/SDA "+str(self.scl)+"/"+str(self.sda))
            with peripheral.device as unident:
                msg = bytearray(len(IDENTITY))
                try:
                    unident.write_then_readinto(IDF,msg)
                except:
                    logger.info("PPC: identifyNew: write failed to I2C peripheral "+str(hex(peripheral.device_address))
                                +" on PPController at SCL/SDA "+str(self.scl)+"/"+str(self.sda))
                    pass
                if msg == IDENTITY:
                    self.devices.append(self.noident.pop(self.noident.index(peripheral)))
                    logger.info("PPC: identifyNew: added PPCDevice "+str(hex(peripheral.device_address))
                                +" to PPController at SCL/SDA "+str(self.scl)+"/"+str(self.sda))
                else:
                    peripheral.retries += 1
                    logger.info("PPC: identifyNew: identification failed "+str(peripheral.retries)+"x "
                                +"for I2C peripheral " +str(hex(peripheral.device_address))
                                +" on PPController at SCL/SDA "+str(self.scl)+"/"+str(self.sda)
                                +" recieved: "+msg.decode())
                    if peripheral.retries > peripheral.retries_max:
                        logger.info("PPC: identifyNew: max retries reached for I2C peripheral"
                                    +str(hex(peripheral.device_address))+" on PPController at SCL/SDA "
                                    +str(self.scl)+"/"+str(self.sda)+". Releasing.")
                        self.othrdev.append(self.noident.pop(self.noident.index(peripheral)))
                        del self.otherdev[-1].device

    def autoAddDevices(self):
        self.scanForNew()
        self.identifyNew()

    def listdevices(controller):
        return self.devices
