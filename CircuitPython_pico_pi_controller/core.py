# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['polling_interval', 'poll_fail_max', 'IDENTITY', 'IDF', 'HOS', 'LOD', 'TIM', 'PEN', 'PPDevice',
           'PPController']

# Cell
from sys import byteorder, modules
try:
    from rtc import RTC
except:
    pass
from time import sleep, struct_time
from datetime import datetime
#from board import SCL,SDA
import board
import busio
from adafruit_bus_device.i2c_device import I2CDevice
try:
    from adafruit_itertools.adafruit_itertools import chain
except:
    from itertools import chain
try:
    import adafruit_logging as logging
except:
    import logging

# Cell
polling_interval = 2
poll_fail_max = 11
#IDENTITY = bytearray('ppc-daemon','utf-8') # of RPi devices
IDENTITY = bytearray(([ord(c) for c in list('ppc-daemon')]))
"""identifier string used by RPi devices"""

# Cell
#IDF = bytearray('I','utf-8') # request to send identification
#HOS = bytearray('H','utf-8') # request to send hostname
#LOD = bytearray('L','utf-8') # request to send load
#TIM = bytearray('T','utf-8') # request to send datetime
#PEN = bytearray('P','utf-8') # request to send MCU pin connected to RPi PEN

IDF = bytearray(); IDF.append(ord('I')) # request to send identification
HOS = bytearray(); HOS.append(ord('H')) # request to send hostname
LOD = bytearray(); LOD.append(ord('L')) # request to send load
TIM = bytearray(); TIM.append(ord('T')) # request to send datetime
PEN = bytearray(); PEN.append(ord('P')) # request to send MCU pin connected to RPi PEN

# Cell
class PPDevice(I2CDevice):
    """Represents an I2C peripheral device known to a `PPController`
    and stores data from those peripherals identified as PPC devices."""
    def __init__(self, i2c, device_address, **kwargs):
        super().__init__(i2c,device_address,**kwargs)
        self.device_address = device_address

        self.bosmang = False
        self.UART_RX = UART_RX
        """MCU GPIO RX for passthru from bosmang console TX"""
        self.UART_TX = UART_TX
        """MCU GPIO TX for passthru from bosmang console RX"""
        self.pen = 0
        """MCU GPIO connected to RPi PEN pin"""
        self.retries = 0
        """retry count before I2CDevice is considered 'other', i.e. not a PPC device."""

        self.hostname = "unknown"
        self.load = ""
        self.datetime = None
        """to send datetime as bosmang, and used to check for datetime skew
           on other devices."""

    def getHostname(self):
        return self.hostname

# Cell
class PPController(busio.I2C):
    """Represents one of the system's I2C busses and tracks which I2C
    peripherals are `PPDevice`s."""
    def __init__(self, scl=board.SCL, sda=board.SDA, frequency=4800, timeout=10000, bosmang=None):
        self.scl = scl
        self.sda = sda
        self.frequency=frequency
        self.timeout=timeout
        logging.info("Using I2C bus on pins",scl,sda,"at frequency",frequency,"with timeout",timeout)
        try:
            super().__init__(scl, sda, frequency=frequency, timeout=timeout)
        except:
            super().__init__(scl, sda, frequency=frequency)
            """Blinka does not have keyword argument `timeout`"""
        self.bosmang = bosmang
        """PPDevice hostname selected to recieve datetime & control instructions from,
           have UART connected for passthru, etc. Default is `None`."""

        self.devices = []
        self.noident = []
        self.othrdev = []

        self.datetime = 0
        """future use for receiving datetime from bosmang"""

    def addDevice(self, *args):
        self.devices.append(PPDevice(i2c=self,device_address=args[0]))


    def scanForNew(self):
        while not self.try_lock():
            sleep(.1)
            pass
        for addr in self.scan():
            if not any(d.device_address == addr
                       for d in chain(self.devices,self.noident,self.othrdev)):
                self.noident.append(PPDevice(i2c=self,device_address=addr))
        self.unlock()

    def identifyNew(self):
        for d in self.noident:
            with d:
                msg = bytearray(len(IDENTITY))
                try:
                    d.write_then_readinto(IDF,msg)
                except:
                    pass
            if msg == IDENTITY:
                self.devices.append(self.noident.pop(self.noident.index(d)))
            else:
                d.retries += 1
                if d.retries >= poll_fail_max:
                    self.othrdev.append(self.noident.pop(self.noident.index(d)))


    def autoAddDevices(self):
        scanForNew()
        identifyNew()

    def listdevices(self):
        return self.devices